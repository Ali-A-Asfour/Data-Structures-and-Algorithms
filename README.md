<h1>Data Structures and Algorithms</h1>
<h2>Description</h2>
<p>This project serves as an introductory journey into data structures and algorithms. I will explore various data structures, writing code in Java, discussing time complexity in different scenarios, and ultimately exploring their practical applications.</p>

<h2>Different Data Structures and Algorithms We Will Cover</h2>
<ol>
  <li>
    <strong>Merge Sort:</strong>
    <ul>
      <li>Divide and Conquer algorithm that breaks down lists into smaller sublists for sorting, then merges them back together.</li>
      <li>Time Complexity: O(n log n) for best, average, and worst cases.</li>
      <li>Practical Use: Efficiently sorting large datasets, database sorting algorithms.</li>
    </ul>
  </li>
  <li>
    <strong>Stack:</strong>
    <ul>
      <li>Last-In-First-Out (LIFO) principle, where the last element added is the first to be removed.</li>
      <li>Time Complexity: O(1) for push, pop, and peek operations.</li>
      <li>Practical Use: Managing function calls (call stack), undo mechanisms in software.</li>
    </ul>
  </li>
  <li>
    <strong>Quick Sort:</strong>
    <ul>
      <li>Divide and Conquer strategy that selects a pivot element and partitions the array around the pivot.</li>
      <li>Best and Average Time Complexity: O(n log n).</li>
      <li>Worst Time Complexity: O(n^2).</li>
      <li>Practical Use: General-purpose sorting, in-memory sorting.</li>
    </ul>
  </li>
  <li>
    <strong>Queue:</strong>
    <ul>
      <li>First-In-First-Out (FIFO) method, where the first element added is the first to be removed.</li>
      <li>Time Complexity: O(1) for enqueue, dequeue, and front operations.</li>
      <li>Practical Use: Order processing, resource scheduling in computing.</li>
    </ul>
  </li>
  <li>
    <strong>Insertion Sort:</strong>
    <ul>
      <li>Simple sorting algorithm that builds the final sorted array one item at a time.</li>
      <li>Best Time Complexity: O(n) for an already sorted array.</li>
      <li>Average and Worst Time Complexity: O(n^2).</li>
      <li>Practical Use: Useful for small datasets or nearly sorted arrays.</li>
    </ul>
  </li>
  <li>
    <strong>Selection Sort:</strong>
    <ul>
      <li>Simple sorting algorithm that repeatedly finds the minimum element and places it at the beginning.</li>
      <li>Time Complexity: O(n^2) for best, average, and worst cases.</li>
      <li>Practical Use: Suitable for small datasets where memory space is a constraint.</li>
    </ul>
  </li>
</ol>

<!-- Syntax Highlighting -->
<!--
 ```diff
- text in red
+ text in green
! text in orange
# text in gray
@@ text in purple (and bold)@@
